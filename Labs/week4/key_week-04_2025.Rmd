---
title: "EEMB 179/279: Lab 4 Disease Models - KEY"
author: "your name here"
output:
  html_document:
    df_print: paged
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# EEMB 179: Lab 4 - Modeling the spread of infectious disease

In this lab, we will simulate the spread of an infectious disease, and study how (1) infectiousness, (2) duration of illness, and (3) vaccination impact the potential 'epidemic' nature of the disease.

This lab has 2 parts (plus homework):

First, we will work in small groups (of 3 or 4) to perform a virtual simulation of disease spread. 

We'll enter the data from our virtual simulations into a Google Sheet. We can compare how different parameters altered our simulations.

Second, we'll simulate disease spread using computer models coded in R. This is a much less labor-intensive way of simulating disease spread! That means we'll be able to study the effects of a wide range of parameters (e.g., beta, gamma, and p) in a short amount of time.

# 0. Download deSolve

If you don't already have the package `deSolve`, uncomment this line of code and run it!

```{r}
# install.packages("deSolve", dependencies = T)
```

To load in the package, run either of these two lines (they do the same thing).

```{r}
library(deSolve) # load the package deSolve
require(deSolve) # remember you can use either library() or require() to load packages
```

And last, at the end of this script, you'll find the homework assignment for this week. 

# 1. Virtual simulation - Have fun!

We will be using a virtual disease simulation tool to explore epidemic scenarios. Each group will be altering at least 2 parameters in a series of models. Think about what results your manipulations might lead to. Does the model reflect your hypothesis? http://tachyondecay.github.io/epidemic-simulator/

In your groups, fill out the spreadsheet describing the results of your simulations. Your TA will assign your group number. https://docs.google.com/spreadsheets/d/19T6cgB47P22uoRGAsf0ANsl6i1hXjj0Gl0Yaz574IJQ/edit?usp=sharing

# 2. Simulating disease computationally

Throughout this section, we'll be using the following equations:

$$
\begin{align}
\frac{d N}{dt}  &= 0 \\ 
\newline
\frac{d S}{dt} &= -\beta S I\\
\newline
\frac{d I}{dt} &= \beta S I - \gamma I\\
\newline
\frac{d R}{dt} &= \gamma I\\
\end{align}
$$

## a. Basic disease simulation using a `for()` loop or an ODE Solver

In this class, we use `for()` loops to analyze our models. However, there are tools called **ODE solvers** that are packages that will also analyze your model. "ODE" stands for **O**rdinary **D**ifferential **E**quations, which is what our models are made of (see above). We're showing you this tool in order to present another option for you to use, in particular in your final project.  

ODE solvers are especially useful when you're solving equations that are "computationally intensive" - generally, these are complex networks of equations. None of the equations we work on in this class are necessarily computationally intensive, so they're great practice to get the hang of using an ODE solver.  

### Simulation using a `for()` loop

First, let's set up our parameters $\beta$ (infection rate) and $\gamma$ (recovery rate). Remember that you can see LaTeX text (everything between the $ operators) rendered if you hover your cursor above it.
```{r}
beta <- 0.01   # infection rate
gamma <- 0.1  # recovery rate
```

Second, let's specify the initial conditions for our simulation. Here, we're assuming this is a new disease that is introduced to the population by 1 person. Therefore, $S_0 = N - I_0$ because all individuals are susceptible to the disease. Additionally, because the disease is new, there are no recovered individuals ($R_0 = 0$)
```{r}
# population size
N <- 100   

# initial infected individual
I0 <- 1		

# starting number of susceptibles
S0 <- N - I0	

# starting number of recovered individuals
R0 <- 0 	
```

Third, we'll set up our storage variables and fill them with our initial conditions. **Note:** Now we'll need one for each "state" of the population.
```{r}
# time steps
tset <- seq(from = 0, to = 60, length.out = 20000) # sequence of timesteps from 0 to 60 with a length of 20000

# holding vector for N (population size)
N.simu1 <- NaN*tset # vector of the same length as tset that is filled with NaNs
N.simu1[1] <- N # set the initial population size

# holding vector for I (infected individuals)
I.simu1 <- NaN*tset# vector of the same length as tset that is filled with NaNs
I.simu1[1] <- I0 # set the initial number of infected individuals

# holding vector for S (susceptible individuals)
S.simu1 <- NaN*tset # vector of the same length as tset that is filled with NaNs
S.simu1[1] <- S0 # set the initial number of susceptible individuals

# holding vector for R (recovered individuals)
R.simu1 <- NaN*tset # vector of the same length as tset that is filled with NaNs
R.simu1[1] <- 0 # set the initial number of recovered individuals
```

Fourth, we'll run a `for()` loop to simulate the dynamics of the system. This is has the same format as what we've been using in previous labs to calculate population sizes at each time step, but with a small modification: within the loop, we create variables called `S`, `I`, and `R` for the population sizes at the previous timestep (e.g. `S.simu1[i-1]`).  

These variables get overwritten with each iteration of the `for()` loop, so they're somewhat inefficient. However, they make the equations for `dS`, `dI`, and `dR` more simple and therefore less prone to error, so it's worth doing.
```{r}
# for each element i from the second to the last
for(i in 2:length(tset)){
  # calculate change in time
	dt <- tset[i]-tset[i-1] # change in time is the difference between the ith timepoint and the previous timepoint
	
	# assign S, I, and R
	S <- S.simu1[i-1] # susceptible individuals at previous timepoint
	I <- I.simu1[i-1] # infected individuals at previous timepoint
	R <- R.simu1[i-1] # recovered individuals at previous timepoint
	
	# calculate change in size of each stage
	dS <- (-beta * S * I)*dt # change in number of susceptible individuals over the time interval dt
	dI <- (beta*S*I - gamma*I)*dt # change in number of infected individuals over the time interval dt
	dR <- (gamma * I)*dt # change in number of recovered individuals over the time interval dt
	dN <- dS+dI+dR  # change in population size over the time interval dt
	
	# calculate total size of each stage and store in holding vector
	S.simu1[i] <- S + dS # number of susceptible individuals at ith timepoint is equal to the number of susceptible individuals at the previous timepoint (remember we set S <- S.simu1[i-1]) plus the change in susceptible individuals over the time interval dt
	I.simu1[i] <- I + dI # number of infected individuals at ith timepoint is equal to the number of infected individuals at the previous timepoint plus the change in infected individuals over the time interval dt
	R.simu1[i] <- R + dR # number of recovered individuals at ith timepoint is equal to the number of recovered individuals at the previous timepoint plus the change in recovered individuals over the time interval dt
	N.simu1[i] <- N + dN # the population size at ith timepoint is equal to the population size at the previous timepoint plus the change in population size over the time interval dt
}
```

Make sure you check the output of your `for()` loop! Use `head()` and `tail()` to look at the beginning and end to make sure things ran the way they were supposed to.  

We'll check `S.simu1`.
```{r}
head(S.simu1) # use head() to look at the first 6 elements of S.simu1
tail(S.simu1) # use tail() to look at the last 6 elements of S.simu1
```

Looks like the loop worked! Now, we can create a few plots to examine our output. We'll be making a lot of timeseries plots where lines are laid on top of each other, so we can store some colors to use that are consistent across each plot.
```{r}
Ncol <- 'black' # color to use for plotting population size
Scol <- 'dodgerblue3' # color to use for plotting number of susceptible individuals
Icol <- 'coral' # color to use for plotting number of infected individuals
Rcol <- 'darkgoldenrod4' # color to use for plotting number of recovered individuals
```

First, let's double check that we coded everything in correctly by checking the output of `N.simu1`. Remember that $\frac{dN}{dt} = 0$, so $N$ should be the same at each timestep. We'll plot $N$ as a function of time first, and what we expect is a horizontal line with a y-intercept at 100.
```{r}
plot(x = tset, y = N.simu1,  # x-variable = time, y- variable = population size
     type = 'l', # plot data as a line
     col = Ncol, # use the color we assigned for population size
     las = 1, # horizontal y-axis tick marks
     lwd = 2, # line thickness
     xlab = 'Time', ylab = 'Number of Individuals') # x and y-axis labels
```

Looks like it worked! We can also check by looking at the standard deviation of `N.simu1` using the `sd()` function _or_ looking at the last number in `N.simu1`.
```{r}
sd(N.simu1) # standard deviation of the values in N.simu1
N.simu1[length(tset)] # final value of N.simu1 (remember N.simu1 and tset are the same length, so the final position in N.simu1 will be the length of tset)
```

Now, let's look at how individuals moved between classes using a timeseries plot.
```{r}
# plot N.simu1
plot(x = tset, y = N.simu1, # x-variable = time, y- variable = population size
     type = 'l', # plot data as a line
     col = Ncol, # use the color we assigned for population size
     las = 1, # horizontal y-axis tick marks
     lwd=2, # line thickness
     xlab = 'Time', ylab = 'Number of Individuals', # x and y-axis labels
     ylim = c(0,N*1.2)) # y-axis limits

# add a horizontal line at 0
abline(h = 0)

# add lines showing the number of susceptibles, infected, and recovered individuals
# plot susceptibles (S.simu1)
lines(x = tset, y = S.simu1, col = Scol, lwd = 2) # x = time, y = susceptibles, use the color we assigned for susceptibles, and specify line thickness with lwd
# plot infected individuals (I.simu1)
lines(x = tset, y = I.simu1, col = Icol, lwd = 2)# x = time, y = infected individuals, use the color we assigned for infected individuals, and specify line thickness with lwd
# plot recovered individuals (R.simu1)
lines(x = tset, y = R.simu1, col = Rcol, lwd = 2) # x = time, y = recovered individuals, use the color we assigned for recovered individuals, and specify line thickness with lwd

# add a legend
legend(x = max(tset)*0.1, y = N*1.2, # x and y locations of the legend
       lwd = 2, # thickness of the lines in the legend
       legend = c('N', 'S', 'I', 'R'), # labels for the legend elements
       col = c(Ncol, Scol, Icol, Rcol), # colors for the legend elements
       horiz = TRUE) # arrange the legend elements in a row
```

### Simulation using an ODE solver `deSolve`

The first thing you have to do is set up a function using the `function()` function. This describes your system of equations for the ODE solver to solve.  

`deSolve` expects a function with a specific structure: one that takes arguments `t`, `x`, and `params`. These represent time, population sizes, and parameters, respectively. The following code chunk creates a function called `sir.fun` with these arguments. At the end of the function, the `return()` component lets the function output `dSdt`, `dIdt`, `dRdt`, and `dNdt` at each time step.
```{r}
sir.fun <- function (t, x, params) { # make a function named sir.fun whose arguments are time t, population sizes x (a vector with the size of each "population"/state variable whose dynamics are being simulated over time), and params (a vector with all model parameters)
  # population sizes
  S <- x[1] # the first "population" size in x is the number of susceptible individuals S
  I <- x[2] # the second population size in x is the number of infected individuals I
  R <- x[3] # the third population size in x is the number of recovered individuals R
  N <- x[4] # the fourth population size in x is the total population size N (=S + I + R) 
  
  # parameters
  beta <- params[1] # the first element of params is the parameter beta (infection rate)
  gamma <- params[2] # the second element of params is the parameter gamma (recovery rate)
  
  # change in population size over change in time
  dSdt <- -beta*S*I # change in number of susceptible individuals
  dIdt <- (beta*S*I)-(gamma*I) # change in number of infected individuals
  dRdt <- gamma*I # change in number of recovered individuals
  dNdt <- dSdt+dIdt+dRdt  # change in total population size
  
  # function outputs
  return(list(c(dSdt, dIdt, dRdt, dNdt))) # return a list with the change in each of the state variables over time (first element is the change in number of susceptible indviduals over time, the second element is the change in the number of infected individuals over time, the third element is the change in the number of recovered individuals over time, and the fourth element is the change in the total population size over time)
}
```

Take a moment to look at the equations in the function. What's different about these in comparison to the equations in the `for()` loop?  


The for loop calculates the changes in population sizes (dS, dI, dR, dN) over a specific time interval dt and adds that change to the population size at the previous time point. When using the deSolve ODE solver, you only need to specify the equations for the change in population sizes over time (dS/dt, dI/dt, dR/dt, dN/dt) and the ODE solver will determine the time steps to take

Now, we can set up our initial conditions to go into the arguments `t`, `x`, and `params`, which will then go into the ODE solver's solving function called `lsoda()`. We're using the same initial conditions as we were for the `for()` loop, but let's just assign those values again. We'll also put all these into a **named vector**, which is a vector of numbers where each number has a name. In this example, `S0` is called `S`, `I0` is called `I`, etc.
```{r}
# total population size
N0 <- 100 

# initial number infected
I0 <- 1 

# initial number susceptible
S0 <- N - I0 

# initial number recovered
R0 <- 0 

# named vector of initial values
initial_values <- c(S = S0, I = I0, R = R0, N = N)
```

We can do the same thing for our parameters `beta` and `gamma`, and put them into a vector called `parameters`.
```{r}
# infectivity rate
beta <- 0.01 

# recovery rate
gamma <- 0.1 

# vector of parameters
parameters <- c(beta, gamma) # this will be the params argument in sir.fun
```

The last thing we'll do is create our time vector, called `times`.
```{r}
times <- seq(0, 60, length.out = 20000) # vector of time steps, from 0 to 60 with a length of 20000 
```

Now we're ready to run `lsoda()`! If you're curious about the arguments it takes, check out the help page (`?lsoda`). We'll store the output as the variable `results`.
```{r}
results <- lsoda(initial_values, times, sir.fun, parameters) # use the lsoda() function (an ODE solver from the deSolve package) to simulate the model we specified in sir.fun, with the initial values, timesteps, and parameters assigned above
```

We can also double check the output by using `head()`, as before.
```{r}
head(results) # look at the first 6 elements of the results. Note that lsoda returns the results as a named matrix, where the first column is time (first row = first element of the times vector, second row = second element, etc.) and columns 2-5 are the population sizes S, I, R, and N at each of these timepoints
```

We wanted to compare the ODE solver to a `for()` loop, so let's plot the outputs to do that. First, we'll plot the outputs from the ODE solver:
```{r}
# plot N from ODE solver
plot(x = results[, "time"], y = results[, "N"], # results is a named matrix, so the timepoints are all rows of the "time" column, and the total population sizes at each timepoint are all rows of the "N" column
     # line modifications (plot as a line, specify color, adjust y-axis tick mark labels, specify line thickness)
     type = 'l', col = Ncol, las = 1, lwd = 2, 
     # y-axis limits
     ylim = c(0, N*1.2), 
     # labels
     xlab = 'Time', ylab = 'Number of Individuals', 
     main = "ODE Solver") # use main to label the whole plot

# add a horizontal line at 0
abline(h = 0)

# plot S, I, and R from ODE solver
lines(x = results[, "time"], y = results[, "S"], col = Scol, lwd = 2) # x = time, y = number of susceptible individuals, specify color and line thickness
lines(x = results[, "time"], y = results[, "I"], col = Icol, lwd = 2)# x = time, y = number of infected individuals, specify color and line thickness
lines(x = results[, "time"], y = results[, "R"], col = Rcol, lwd = 2)# x = time, y = number of recovered individuals, specify color and line thickness

# add a legend
legend(x = max(tset)*0.1, y = N*1.2, # legend position
       lwd= 2, # line thickness
       legend = c('N', 'S', 'I', 'R'), # labels of the legend elements
       col = c(Ncol, Scol, Icol, Rcol), # colors of the legend elements
       horiz = TRUE) # arrange as a row
```

Then, we'll plot the output from the `for()` loop:
```{r}
# plot N.simu1 from for() loop
plot(x = tset, y = N.simu1, # x-variable = time, y- variable = population size
     type = 'l', # plot data as a line
     col = Ncol, # use the color we assigned for population size
     las = 1, # horizontal y-axis tick marks
     lwd=2, # line thickness
     xlab = 'Time', ylab = 'Number of Individuals', # x and y-axis labels
     ylim = c(0,N*1.2),# y-axis limits
     main = "for() loop") # title of the plot

# add a horizontal line at 0
abline(h = 0)

# add lines showing the number of susceptibles, infected, and recovered individuals
# plot susceptibles (S.simu1)
lines(x = tset, y = S.simu1, col = Scol, lwd = 2) # x = time, y = susceptibles, use the color we assigned for susceptibles, and specify line thickness with lwd
# plot infected individuals (I.simu1)
lines(x = tset, y = I.simu1, col = Icol, lwd = 2)# x = time, y = infected individuals, use the color we assigned for infected individuals, and specify line thickness with lwd
# plot recovered individuals (R.simu1)
lines(x = tset, y = R.simu1, col = Rcol, lwd = 2) # x = time, y = recovered individuals, use the color we assigned for recovered individuals, and specify line thickness with lwd

# add a legend
legend(x = max(tset)*0.1, y = N*1.2, # x and y locations of the legend
       lwd = 2, # thickness of the lines in the legend
       legend = c('N', 'S', 'I', 'R'), # labels for the legend elements
       col = c(Ncol, Scol, Icol, Rcol), # colors for the legend elements
       horiz = TRUE) # arrange the legend elements in a row
```

Looks like they're the same! Now, let's compare **incidence plots**, where number of infected individuals is plotted as a function of time: 
```{r}
# plot I.simu1 from for() loop
plot(x = tset, y = I.simu1, # x = time, y = number of infected individuals
     type = 'l', las = 1, col = Icol, lwd = 3, # plot data as a line, horizontal y-axis tick labels, line color, line thickness
     xlab = 'Time', ylab = 'Incidence') # x and y-axis labels

# plot I from ODE solver
lines(x = results[, "time"], y = results[, "I"], # x = time, y = number of infected individuals
      col = 'black', lwd = 1, lty = 2) # line color, thickness, and line type (2 = dashed) 

# add a legend
legend(x = max(tset)*0.6, y = max(I.simu1)*0.9, # legend position
       lwd = 2, # line thickness
       legend = c('For() Loop', 'ODE Solver'), # labels of legend elements
       col = c(Icol, 'black'), # colors of legend elements
       lty = c(1, 2)) # line type of the legend elements (1 = solid, 2 = dashed)
```

Again, they look the same. Hooray! Now, for the final test: comparing run times. Which is faster, the `for()` loop or the ODE solver? We can figure this out using the `system.time()` function.
```{r}
# for() loop run time
for.loop.time <- system.time( # everything inside system.time() will be timed when it runs
  # code for simulating the model with a for() loop
  for(i in 2:length(tset)){
    dt <- tset[i]-tset[i-1]
    S <- S.simu1[i-1] 
    I <- I.simu1[i-1]
    R <- R.simu1[i-1]
    dS <- (-beta*S*I)*dt
    dI <- (beta*S*I-gamma*I)*dt
    dR <- (gamma*I)*dt
    dN <- dS+dI+dR 
    S.simu1[i] <- S + dS
    I.simu1[i] <- I + dI
    R.simu1[i] <- R + dR
    N.simu1[i] <- N + dN
  }
) # stop timing

# ODE run time
ode.time <- system.time( # start timing
  # code for simulating the model with lsoda() ODE solver
  lsoda(initial_values, times, sir.fun, parameters)
) # stop timing

# Compare
for.loop.time # time it took to run the for loop
ode.time # time it took to simulate the model with the ODE solver
```

### Think, Pair, Share 1 :
1. What was the maximum number of people that were sick (i.e., in state $I$) at any given time? What R command can you use to find out exactly?
```{r}
max(I.simu1) # use the max() function to calculate the maximum value in I.simu1
```

2. By the time the disease had run its course (i.e., $I$ had fallen back close to zero), what proportion of the population had been sick at some point? Make a plot of the proportion of individuals that were currently, or had been, sick (i.e., $\frac{I + R}{N}$ over time).
```{r}
# Because -- 
# N = S + I + R
# N - S = I + R

## SOLUTION ##
(N - S.simu1[length(tset)]) / N  # proportion of population that has been sick at some point = Proportion of population that was not still susceptible at the end of the simulation
# or #
(I.simu1[length(tset)]+R.simu1[length(tset)]) / N # proportion of population that has been sick at some point = Proportion of population that was either infected or recovered (had been infected at some point during the simulation) at the end of the simulation

## PLOT ##
plot(x = tset, y = (I.simu1+R.simu1)/N, lwd=2, type = 'l', las = 1, ylab = 'Number Infected or Recovered', xlab = 'Time') # x variable = time, y variable = proportion of individuals currently or previously sick (I + R), the specify line type with lwd, tell R to plot the data as a line, make the y-axis tick mark labels horizontal with las = 1, and label the axes
## END SOLUTION ##
```

3. When was the rate of transmission highest? You can figure this out by making a plot of the new infections over time. Hint: remember that the change in number of infected individuals over change in time is $\frac{d I}{dt} = \beta S I - \gamma I$, but that the _new infections_ would be $\beta * S * I$.
```{r}
# because -- 
# rate of transmission = dI/dt
# dI/dt = +B * S * I - gamma*I

## SOLUTION ##
NewInfec <- beta * S.simu1 * I.simu1 # number of newly infecteded individuals from new infections at each time point is equal to beta (infection rate) times the number of susceptible individuals at each time point times the number of infected individuals at each time point
plot(x = tset, y = NewInfec, lwd = 2, type = 'l', las = 1, ylab = 'New Infections', xlab = 'Time') # x = time, y = new infections
max.NewInfec <- max(NewInfec) # the maximum number of new infections that occurred in the simulation is the maximum value in the vector NewInfec

for(i in 1:length(tset)){ # for each time point in the simulation
	if(NewInfec[i]==max.NewInfec){ # if the ith number of new infections is equal to the max number of new infections over the whole simulation
		T.maxnewinf <- tset[i] # store the timepoint (tset[i]) at which this maximum occurred
	}
}
abline(v=T.maxnewinf,lty=2) # add a vertical line at this timepoint to the plot

T.maxnewinf # print the timepoint at which the number of new infections was greatest
## END SOLUTION ##
```

## b. Incorporating vaccination

Let's now consider how we could prevent the spread of this disease through vaccination.

Let's set a vaccination rate $p$ of 0.7, meaning 70% of the population has been vaccinated before this disease arrives.
```{r}
p <- 0.7 # set the vaccination rate p
```

Now, when we start our simulation, our initial conditions will be different. We'll still assume that we start with one infected individual ($I_0 = 1$), but now the number of susceptibles is reduced by vaccination.  

We'll first set our initial conditions, then fill in our holding vectors.
```{r}
# Number vaccinated - doesn't change over time
V <- N*p # the number of vaccinated individuals is equal to the population size multiplied by the vaccination rate

# starting number of susceptibles
S0 <- N - V - I0 # HINT: Why is this the same as N*(1-p)-I0? (Answer: N-V is equal to the number of individuals that are not vaccinated, which is the same as the population size multiplied by the proportion of individuals that are not vaccinated, which is 1-p)

# holding vectors and initial conditions
N.simu2 <- NaN*tset; N.simu2[1] <- N # holding vector for total population size at each timepoint, set initial value to the total population size N
S.simu2 <- NaN*tset; S.simu2[1] <- S0 # holding vector for number of susceptible individuals at each timepoint, set initial value to S0
I.simu2 <- NaN*tset; I.simu2[1] <- I0 # holding vector for number of infected individuals at each timepoint, set initial value to I0
R.simu2 <- NaN*tset; R.simu2[1] <- N - I0 - S0 - V # holding vector for number of recovered individuals at each timepoint, set initial value to the initial number of individuals that are not infected, susceptible, or vaccinated

# for each timestep
for(i in 2:length(tset)){ # for each element i in the second to last element in tset
  # calculate change in time
	dt <- tset[i]-tset[i-1] # change in time is the difference between the ith timepoint and the previous timepoint
	
	# assign S, I, and R
	S <- S.simu2[i-1] # susceptible individuals at previous timepoint
	I <- I.simu2[i-1] # infected individuals at previous timepoint
	R <- R.simu2[i-1] # recovered individuals at previous timepoint
	
	# calculate change in size of each stage
	dS <- (-beta*S*I)*dt # change in number of susceptible individuals over the time interval dt
	dI <- (beta*S*I-gamma*I)*dt # change in number of infected individuals over the time interval dt
	dR <- (gamma*I)*dt # change in number of recovered individuals over the time interval dt
	dN <- dS+dI+dR  # change in population size over the time interval dt
		
	# calculate total size of each stage and store in holding vector
	S.simu2[i] <- S + dS # number of susceptible individuals at ith timepoint is equal to the number of susceptible individuals at the previous timepoint (remember we set S <- S.simu2[i-1]) plus the change in susceptible individuals over the time interval dt
	I.simu2[i] <- I + dI # number of infected individuals at ith timepoint is equal to the number of infected individuals at the previous timepoint plus the change in infected individuals over the time interval dt
	R.simu2[i] <- R + dR # number of recovered individuals at ith timepoint is equal to the number of recovered individuals at the previous timepoint plus the change in recovered individuals over the time interval dt
	N.simu2[i] <- N + dN# the population size at ith timepoint is equal to the population size at the previous timepoint plus the change in population size over the time interval dt
}

```

Check the output of your `for()` loop!
```{r}

head(S.simu2) # use head() to look at the first 6 elements of S.simu2
tail(S.simu2) # use tail() to look at the last 6 elements of S.simu2

```

Let's look at how individuals moved between classes. We'll designate one more color for vaccinated individuals, then plot the output in a timeseries.
```{r}
# assign color for vaccinated line
Vcol <- 'darkorchid3'

# plot N.simu2: model with vaccination
plot(x = tset, y = N.simu2, # x = time, y = total population size
     type = 'l', col=Ncol, las = 1, lwd=2, # plot aesthetics (plot data as a line, specify color, las = 1 for horizontal y-axis tick marks, lwd to adjust line thickness)
     xlab = 'Time', ylab = 'Number of Individuals', # axis labels
     ylim = c(0,N*1.2)) # y-axis limits

# add horizontal line at 0
abline(h = 0)

# plot susceptibles
lines(x = tset, y = S.simu2, col = Scol, lwd = 2)
# plot infected individuals
lines(x = tset, y = I.simu2, col = Icol, lwd = 2)
# plot recovered individuals
lines(x = tset, y = R.simu2, col = Rcol, lwd = 2)
# plot vaccinated individuals
lines(x = tset, y = rep(V,length(tset)), col = Vcol, lwd = 2) # remember the number of vaccinated individuals doesn't change over time (V stays the same). rep(V, length(tset)) makes a vector of the same length as tset that has V in every position. Another way we could have plotted V is to use abline(): abline(h = V, col = Vcol, lwd = 2)

# add a legend
legend(x = max(tset)*0.05, y = N*1.2, # legend position
       lwd = 2, # line thickness
       legend = c('N','S','I','R','V'), # labels for legend elements
       col = c(Ncol, Scol, Icol, Rcol, Vcol), # colors for the legend elements
       horiz = TRUE) # arrange elements in a row
```

Now, let's compare the incidence graphs for the two scenarios (unvaccinated vs. 70% vaccinated).
```{r}
# plot I.simu1 from the unvaccinated population
plot(x = tset, y = I.simu1, 
     col = Icol, type = 'l', lwd = 2, las = 1, 
     xlab = 'Time', ylab = 'Incidence')

# plot I.simu2 from the 70% vaccinated population
lines(x = tset, y = I.simu2, col = 'black', lwd = 2)

# add a legend
legend(x = max(tset)*0.6, y = max(I.simu1)*.9, 
       lwd = 2,
       legend = c('Unvacc.', '70% Vacc'),
       col = c(Icol, 'black'))
```

### Think, Pair, Share 2:
1. How did vaccination change the dynamics that you observed?  

It reduced the incidence, but also prolonged the run of the disease (e.g., there were still infectious individuals around for longer)  

2. Did vaccination create herd immunity? In other words, were any unvaccinated individuals protected? **Hint:** First plot the number of susceptible individuals over time, and look at the number of susceptibles at the end of the disease - what do you notice?
```{r}
## SOLUTION ##
plot(x = tset, y = S.simu1, col = Scol, las = 1, lwd = 2, type = 'l', xlab = 'Time', ylab = 'Number Susceptible') # x variable = time, y variable = number of susceptible individuals over time from the simulation without vaccination, make this a line that has color Scol
lines(x = tset, y = S.simu2, col = 'black', lwd=2)# x variable = time, y variable = number of susceptible individuals over time from the simulation with vaccination, give this line the color black
legend(x = max(tset)*0.6, y = max(S.simu1)*.9, legend = c('Unvacc.','70% Vacc'),lwd = 2, col =c(Scol,'black')) # adding a legend to label the unvaccinated and vaccinated simulations

# or #
S.simu2[length(tset)] # number of susceptible individuals at the end of the simulation with vaccination
I.simu2[length(tset)]  # number of infected individuals at the end of the simulation with vaccination

## END SOLUTION ##
```

Yes, one (or two, if you round up) of the susceptible individuals remained uninfected by the end of the simulation. So this person was protected by herd immunity, though the other susceptibles were not. Also, this simulation hasn't run long enough for the disease to completely disappear (I --> 0), so that person could still get sick.  

3. Add a line to your incidence graph for a higher rate of vaccination, $p_2$, of 0.8. (Don't forget to change the legend!) How does this compare?
```{r}
## SOLUTION ##
p2 <- 0.8 # new vaccination rate
V2 <- N*p2  # new number of vaccinated individuals
S0 <- N - V2 - I0  # new initial number of susceptible individuals

# make the holding vectors and set the initial conditions
N.simu3 <- NaN*tset; N.simu3[1] <- N # holding vector for total population size at each timepoint, set initial value to the total population size N
S.simu3 <- NaN*tset; S.simu3[1] <- S0 # holding vector for number of susceptible individuals at each timepoint, set initial value to S0
I.simu3 <- NaN*tset; I.simu3[1] <- I0 # holding vector for number of infected individuals at each timepoint, set initial value to I0
R.simu3 <- NaN*tset; R.simu3[1] <- N - I0 - S0 - V # holding vector for number of recovered individuals at each timepoint, set initial value to the initial number of individuals that are not infected, susceptible, or vaccinated

for(i in 2:length(tset)){# for each element i in the second to last element in tset
  # calculate change in time
	dt <- tset[i]-tset[i-1] # change in time is the difference between the ith timepoint and the previous timepoint
	
	# assign S, I, and R
	S <- S.simu3[i-1] # susceptible individuals at previous timepoint
	I <- I.simu3[i-1] # infected individuals at previous timepoint
	R <- R.simu3[i-1] # recovered individuals at previous timepoint
	
	# calculate change in size of each stage
	dS <- (-beta*S*I)*dt # change in number of susceptible individuals over the time interval dt
	dI <- (beta*S*I-gamma*I)*dt # change in number of infected individuals over the time interval dt
	dR <- (gamma*I)*dt # change in number of recovered individuals over the time interval dt
	dN <- dS+dI+dR  # change in population size over the time interval dt
	
	# calculate total size of each stage and store in holding vector
	S.simu3[i] <- S + dS # number of susceptible individuals at ith timepoint is equal to the number of susceptible individuals at the previous timepoint (remember we set S <- S.simu2[i-1]) plus the change in susceptible individuals over the time interval dt
	I.simu3[i] <- I + dI # number of infected individuals at ith timepoint is equal to the number of infected individuals at the previous timepoint plus the change in infected individuals over the time interval dt
	R.simu3[i] <- R + dR # number of recovered individuals at ith timepoint is equal to the number of recovered individuals at the previous timepoint plus the change in recovered individuals over the time interval dt
	N.simu3[i] <- N + dN# the population size at ith timepoint is equal to the population size at the previous timepoint plus the change in population size over the time interval dt
	
}

# plot the number of infected individuals over time from each of our three simulations (no vaccination, 70% vaccinated, and 80% vaccinated)
plot(x = tset, y = I.simu1, col = Icol, type='l', lwd = 2, las = 1, xlab = 'Time',ylab='Incidence') # x = time, y = number of infected individuals at each time point from the simulation without vaccination
lines(x = tset, y = I.simu2, col = 'black', lwd = 2) # x = time, y = number of infected individuals at each time point from the simulation with 70% vaccination
lines(x = tset, y = I.simu3, col = 'blue', lwd = 2) # x = time, y = number of infected individuals at each time point from the simulation with 80% vaccination
legend(x = max(tset)*0.6, y = max(I.simu1)*.9, legend = c('Unvacc.','70% Vacc','80% Vacc'),lwd = 2, col =c(Icol,'black','blue')) # add a legend labeling each simulation being plotted

# In this case, the disease spreads even less. We can also see from

S.simu3[length(tset)] # final number of susceptible individuals for simulation with 80% vaccination
S.simu2[length(tset)] # final number of susceptible individuals for simulation with 70% vaccination
R.simu3[length(tset)] # final number of recovered individuals for simulation with 80% vaccination
R.simu2[length(tset)] # final number of recovered individuals for simulation with 70% vaccination
I.simu3[length(tset)] # final number of infected individuals for simulation with 80% vaccination
I.simu2[length(tset)] # final number of infected individuals for simulation with 70% vaccination
# that more individuals benefited from herd immunity, though a number still got sick.

## END SOLUTION ##
```

in this case, the disease spreads even less.

## c. Calculating vaccination rates to prevent an outbreak
Let's say you were a public health official interested in preventing this disease from having the potential to create an epidemic in your population. Your goal is to bring the basic reproduction number $R_0$ below 1.

Recall: 

$$
\begin{align}
R_0 &= \frac{\beta S}{\gamma} \\ 
\end{align}
$$
What is $R_0$ for this disease when it _first_ enters the population?
```{r}
R0 <- beta * N / gamma # basic reproduction number of the disease

# Why are we using N in place of S in the above formulation? (Answer: when the disease first enters the population, we can assume that everyone is susceptible, so S = N)
```

Recall that:
$$
\begin{align}
R_V &= R_0 (1-p) \\ 
\end{align}
$$

What level of vaccination (let's call it `p_crit` for "critical vaccination level") would prevent this disease from having an epidemic? HINT: Set $R_V = 1$.
```{r}
p_crit <- 1 - 1/R0 # critical vaccination level that would prevent an epidemic: if R_V = 1, then 1 = R0(1-p), so 1/R0 = 1-p, so p = 1 - 1/R0
```

Let's check that prediction by calculating population sizes with this new $p_{crit}$.
```{r}
# set initial conditions
V3 <- N*p_crit   # set the number of vaccinated individuals equal to the critical number that would prevent an epidemic in this population
S0 <- N - V3 - I0  # initial number of susceptible individuals = all individuals that are not vaccinated or initially infected

# create holding vectors and fill with initial conditions
N.simu4 <- NaN*tset; N.simu4[1] <- N # holding vector for total population size at each timepoint, set initial value to the total population size N
S.simu4 <- NaN*tset; S.simu4[1] <- S0 # holding vector for number of susceptible individuals at each timepoint, set initial value to S0
I.simu4 <- NaN*tset; I.simu4[1] <- I0 # holding vector for number of infected individuals at each timepoint, set initial value to I0
R.simu4 <- NaN*tset; R.simu4[1] <- N - I0 - S0 - V3 # holding vector for number of recovered individuals at each timepoint, set initial value to the initial number of individuals that are not infected, susceptible, or vaccinated

# for each element i from the second to the last
for(i in 2:length(tset)){
  # calculate change in time
	dt <- tset[i]-tset[i-1] # change in time is the difference between the ith timepoint and the previous timepoint
	
	# assign S, I, and R
	S <- S.simu4[i-1] # susceptible individuals at previous timepoint
	I <- I.simu4[i-1] # infected individuals at previous timepoint
	R <- R.simu4[i-1] # recovered individuals at previous timepoint
	
	# calculate change in size of each stage
	dS <- (-beta * S * I)*dt # change in number of susceptible individuals over the time interval dt
	dI <- (beta*S*I - gamma*I)*dt # change in number of infected individuals over the time interval dt
	dR <- (gamma * I)*dt # change in number of recovered individuals over the time interval dt
	dN <- dS+dI+dR  # change in population size over the time interval dt
	
	# calculate total size of each stage and store in holding vector
	S.simu4[i] <- S + dS # number of susceptible individuals at ith timepoint is equal to the number of susceptible individuals at the previous timepoint (remember we set S <- S.simu4[i-1]) plus the change in susceptible individuals over the time interval dt
	I.simu4[i] <- I + dI # number of infected individuals at ith timepoint is equal to the number of infected individuals at the previous timepoint plus the change in infected individuals over the time interval dt
	R.simu4[i] <- R + dR # number of recovered individuals at ith timepoint is equal to the number of recovered individuals at the previous timepoint plus the change in recovered individuals over the time interval dt
	N.simu4[i] <- N + dN # the population size at ith timepoint is equal to the population size at the previous timepoint plus the change in population size over the time interval dt
}

```

Check the output of your `for()` loop!
```{r}

head(S.simu4)
tail(S.simu4)

```

Now, let's plot a timeseries.
```{r}
# plot N.simu4
plot(x = tset, y = N.simu4, # x = time, y = total population size for simulation with critical vaccination level
     type = 'l', col = Ncol, las = 1, lwd = 2, # plot aesthetics (tell R to plot data as a line, specify the color, make y-axis tick labels horizontal, specify line thickness)
     xlab = 'Time', ylab = 'Number of Individuals', # label the axes
     ylim = c(0,N*1.2)) # set the y-axis limits

# add a horizontal line at 0
abline(h = 0)

# plot susceptibles
lines(x = tset, y = S.simu4, col = Scol, lwd = 2) # x = time, y = number of susceptibles for simulation with critical vaccination level
# plot infected individuals
lines(x = tset, y = I.simu4, col = Icol, lwd = 2)
# plot recovered individuals
lines(x = tset, y = R.simu4, col = Rcol, lwd = 2)
# plot vaccinated individuals
lines(x = tset, y = rep(V3, length(tset)), col = Vcol, lwd = 2) # remember the number of vaccinated individuals is the same at each timepoint. rep(V3, length(tset)) makes a vector of the same length as tset that has V3 in each position

# add a legend
legend(x = max(tset)*0.05, y = N*1.2, # legend position
       lwd = 2, # line thickness
       legend = c('N', 'S', 'I', 'R', 'V'), # legend labels
       col = c(Ncol, Scol, Icol, Rcol, Vcol), # colors for the legend elements
       horiz = TRUE) # arrange legend elements in a row
```

Let's zoom in on the susceptible, infected, & recovered to see what's going on a bit better. This is almost the same code as above, but now we're setting a different `ylim` value.
```{r}
# plot S.simu4
plot(x = tset, y = S.simu4, # x = time, y = number of susceptible individuals for simulation with critical vaccination level
     type = 'l', col = Scol, las = 1, lwd = 2, # plot aesthetics
     xlab = 'Time', ylab = 'Number of Individuals', # axis labels
     ylim = c(0,max(S.simu4)*1.2)) # new y axis limits

# add a horizontal line at 0
abline(h = 0)

# plot I.simu4
lines(x = tset, y = I.simu4, col = Icol, lwd = 2) # number of infected individuals over time for the simulation with critical vaccination level
# plot R.simu4
lines(x = tset, y = R.simu4, col = Rcol, lwd = 2) # number of recovered individuals over time for the simulation with critical vaccination level

# add a legend
legend(x = max(tset)*0.1, y = max(S.simu4)*1.2, # legend position
       lwd = 2, # line thickness
       legend = c('S','I','R'), # labels of the legend elements
       col = c(Scol, Icol, Rcol), # colors of the legend elements
       horiz = TRUE) # arrange legend elements in a row
```

What we can see is that, while not all susceptible individuals were protected by herd immunity, the number of sick individuals declined monotonically (that is, was always declining at all times) over time. So, we prevented an outbreak!

We can also see this by adding this scenario to our incidence graph:
```{r}
# plot infected individuals from unvaccinated population
plot(x = tset, y = I.simu1, # x = time, y = number of infected individuals from simulation with no vaccination
     col = Icol, type = 'l', lwd = 2, las = 1, # plot aesthetics
     xlab = 'Time', ylab = 'Incidence') # axis labels

# plot infected individuals from 70% vaccinated population
lines(x = tset, y = I.simu2, col = 'black', lwd = 2)
# plot infected individuals from 80% vaccinated population
lines(x = tset, y = I.simu3, col = 'blue', lwd = 2)
# plot infected individuals from 90% vaccinated population (critical vaccination level)
lines(x = tset, y = I.simu4, col = 'orchid', lwd = 2)

# add a legend
legend(x = max(tset)*0.6, y = max(I.simu1)*.9, # legend location
       lwd = 2, # line thickness
       legend = c('Unvacc.', '70% Vacc', '80% Vacc', '90% Vacc'), # labels of legend elements
       col = c(Icol, 'black', 'blue', 'orchid')) # colors of the legend elements
```

## d. Dependence of R_0 and p_crit on disease biology
Let's consider how $R_0$, and the corresponding vaccination rate that we need to prevent an outbreak, depend on one of the parameters, $\beta$.

First, given that:

$$
\begin{align}
R_0 &= \frac{\beta N}{\gamma} \\ 
\end{align}
$$

What prediction would you make for $R_0$ as $\beta$ increases? For $p_crit$ as $\beta$ increases? Do these predictions make biological sense?

Let's compute $\beta$, $R_0$, and $p_{crit}$:
```{r}
# create a vector of values of beta over which to calculate R0
beta_set <- seq(from = 0.001, to = 0.1, length.out = 100) # sequence from 0.001 to 0.1 with a total length of 100

# calculate R0 for each value of beta
R0_set <- beta_set*N/gamma # R0 = beta*N/gamma

# calculate p_crit for each value of R0
p_crit_set <- 1 - 1/R0_set  # p_crit = 1 - 1/R0
```

Now we can visualize. First, $\beta$ as a function of $R_0$:
```{r}
plot(x = beta_set, y = R0_set, # x = infectiousness, y = basic reproductive number for each value of infectiousness
     type = 'l', las = 1, lwd = 2, # plot aesthetics
     xlab = 'Infectiousness (beta)', ylab = 'Basic Reproductive Number (R_0)') # axis labels
```

Then, $\beta$ as a function of $p_{crit}$:
```{r}
plot(x = beta_set, y = p_crit_set, # x = infectiousness, y = critical vaccination rate needed to prevent an epidemic for each value of infectiousness
     type = 'l', las = 1, lwd = 2, # plot aesthetics
     xlab = 'Infectiousness (beta)', ylab = 'Critical Vaccination Rate (p_crit)') # plot labels
```

And as a bonus, $R_0$ as a function of population size $N$:
```{r}
# create a vector of values for N over which to calculate R0
Nset <- seq(from = 0, to = 100, length.out = 100) # sequence from 1 to 100 with a total length of 100

# calculate R0 for each value of N
R0_set.N <- beta*Nset/gamma # R0 = beta*N/gamma

# plot R0 as a function of N
plot(x = Nset, y = R0_set, # x = total population size, y = basic reproductive number for each population size
     type = 'l', las = 1, lwd = 2, # plot aesthetics
     xlab = 'Population size (N)', ylab = 'Basic Reproductive Number (R_0)') # axis labels

```


# 3. Bonus Material

Researchers at University of Georgia have put together a series of Shiny/R Apps for simulating disease. Explore their [collection of models](https://shiny.ovpr.uga.edu/DSAIDE/). You can also download their code.

If you are interested in coding more advanced simulations of disease spread, check out work on [epidemic simulators with transparent coding](https://reactfordataviz.com/articles/corona-simulation/).

